//****************************************************************************
// Model: ButtonLED_Arduino.qm
// File:  ./arduinoBSP.ino
//
// This code has been generated by QM tool (see state-machine.com/qm).
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This program is open source software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
// for more details.
//****************************************************************************
// @(/2/0) ...................................................................
// Setup
// Include the following libraries

#include "qp_port.h"
#include "Arduino.h"
#include <avr/interrupt.h>
#include <avr/power.h>
#include <avr/sleep.h>
#include <avr/io.h>

// Set the namespace QP

Q_DEFINE_THIS_FILE

using namespace QP;

// Defines

#define BSP_TICKS_PER_SEC 10
#define POLLING_TICKS_PER_SEC 1
#define CLEARING_TICKS_PER_SEC 15
#define DELAY_TICKS_PER_SEC 10

// Enumerate pins and signals

enum PINS {
    PUSHBUTTON_PIN=8,
    LED_PIN=4,
};

enum ButtonSignals {
    TIMEOUT_SIG=Q_USER_SIG,
    PUSHBUTTON_SIG,
    MAX_PUB_SIG,
    MAX_SIG
};

bool buttonRead=LOW;

// Local-scope objects -------------------------------------------------------
static QEvt const *l_ButtonsQueueSto[100];
static QEvt const *l_ControlLEDQueueSto[100];
static QSubscrList l_subscrSto[MAX_SIG];
static QF_MPOOL_EL(QEvt) l_smlPoolSto[700]; // storage for the small event pool



// BSP Initialization Function................................................
void BSP_init(void) {
    //DDRB  = 0xFF; // All PORTB pins are outputs (user LED)
    //PORTB = 0x00; // drive all pins low


    //Declare Pins here
    pinMode(PUSHBUTTON_PIN, INPUT); //Initiates push button pin

    pinMode(LED_PIN, OUTPUT); //Initiates LED Pin as output
    Serial.begin(115200);
}
//............................................................................
void BSP_ledOff(void) {
    digitalWrite(LED_PIN, LOW);
}

void BSP_ledOn(void) {
    digitalWrite(LED_PIN, HIGH);
}

//............................................................................
ISR(TIMER2_COMPA_vect) {
    QF::TICK((void *)0); // process all armed time events
}
//............................................................................
void QF::onStartup(void) {
    // set Timer2 in CTC mode, 1/1024 prescaler, start the timer ticking

    // Use the I/O clock for timer.
    // Note: Changing this value can corrupt TCNT2, OCR2A, OCR2B,
    //       TCCR2A, TCCR2B.  As a result, this should be set before any of
    //       those
    ASSR  &= ~(1 << AS2);

    // Set to CTC mode.
    // Note that WG22 must also be set to 0.
    TCCR2A = (1 << WGM21) | (0 << WGM20);

    // Set the prescalar to 1/2^10
    TCCR2B = (1 << CS22 ) | (1 << CS21) | (1 << CS20);

    // Set to use TIMER2 Compare interrupt 'A'
    TIMSK2 = (1 << OCIE2A);

    // Initialize timer value to 0.
    TCNT2  = 0;

    // Initialize Compare value
    // F_CPU comes from Makefile, default is 16000000
    // BSP_TICKS_PER_SEC is set at the top of this file
    OCR2A  = (F_CPU / BSP_TICKS_PER_SEC / 1024) - 1;

}
//............................................................................
void QF::onCleanup(void) {
}
//............................................................................
void QF::onIdle() {
    QF_INT_ENABLE(); // re-enable interrupts
}
//............................................................................
void Q_onAssert(char const Q_ROM * const Q_ROM_VAR file, int line) {
    QF_INT_DISABLE(); // disable all interrupts
    BSP_ledOff(); // User LED permanently ON
    asm volatile ("jmp 0x0000"); // perform a software reset of the Arduino
}

//============================================================================
// generate code for the Buttons application...
// @(/1/1) ...................................................................
class ControlLED : public QP::QActive {
public:
    ControlLED()
      : QActive(Q_STATE_CAST(&ControlLED::initial))    {
        // empty
    }

protected:
    static QP::QState initial(ControlLED * const me, QP::QEvt const * const e);
    static QP::QState ledOff(ControlLED * const me, QP::QEvt const * const e);
    static QP::QState ledOn(ControlLED * const me, QP::QEvt const * const e);
};


// @(/1/1) ...................................................................

// @(/1/1/1) .................................................................
// @(/1/1/1/0)
QP::QState ControlLED::initial(ControlLED * const me, QP::QEvt const * const e) {
    me->subscribe(PUSHBUTTON_SIG);
    return Q_TRAN(&ControlLED::ledOff);
}
// @(/1/1/1/1) ...............................................................
QP::QState ControlLED::ledOff(ControlLED * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // @(/1/1/1/1)
        case Q_ENTRY_SIG: {
            digitalWrite(LED_PIN, LOW);
            status_ = Q_HANDLED();
            break;
        }
        // @(/1/1/1/1/0)
        case PUSHBUTTON_SIG: {
            status_ = Q_TRAN(&ControlLED::ledOn);
            break;
        }
        default: {
            status_ = Q_SUPER(&QP::QHsm::top);
            break;
        }
    }
    return status_;
}
// @(/1/1/1/2) ...............................................................
QP::QState ControlLED::ledOn(ControlLED * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // @(/1/1/1/2)
        case Q_ENTRY_SIG: {
            digitalWrite(LED_PIN,HIGH);
            status_ = Q_HANDLED();
            break;
        }
        // @(/1/1/1/2/0)
        case PUSHBUTTON_SIG: {
            status_ = Q_TRAN(&ControlLED::ledOff);
            break;
        }
        default: {
            status_ = Q_SUPER(&QP::QHsm::top);
            break;
        }
    }
    return status_;
}


// @(/1/0) ...................................................................
class Buttons : public QP::QActive {
private:
    QP::QTimeEvt m_timeEvt1;

public:
    Buttons()
      : QActive(Q_STATE_CAST(&Buttons::initial)),
        m_timeEvt1(TIMEOUT_SIG)    {
    }

protected:
    static QP::QState initial(Buttons * const me, QP::QEvt const * const e);
    static QP::QState Pressed(Buttons * const me, QP::QEvt const * const e);
    static QP::QState Not_Pressed(Buttons * const me, QP::QEvt const * const e);
};


// @(/1/0) ...................................................................

// @(/1/0/2) .................................................................
// @(/1/0/2/0)
QP::QState Buttons::initial(Buttons * const me, QP::QEvt const * const e) {
    return Q_TRAN(&Buttons::Not_Pressed);
}
// @(/1/0/2/1) ...............................................................
QP::QState Buttons::Pressed(Buttons * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // @(/1/0/2/1)
        case Q_ENTRY_SIG: {
            Serial.println("The Button has been pressed");
            me->m_timeEvt1.postEvery(me, 30);
            status_ = Q_HANDLED();
            break;
        }
        // @(/1/0/2/1)
        case Q_EXIT_SIG: {
            me->m_timeEvt1.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // @(/1/0/2/1/0)
        case TIMEOUT_SIG: {
            // @(/1/0/2/1/0/0)
            if (digitalRead(PUSHBUTTON_PIN)==LOW) {
                status_ = Q_HANDLED();
            }
            // @(/1/0/2/1/0/1)
            else {
                QF::publish(Q_NEW(QEvt, PUSHBUTTON_SIG));

                status_ = Q_TRAN(&Buttons::Not_Pressed);
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QP::QHsm::top);
            break;
        }
    }
    return status_;
}
// @(/1/0/2/2) ...............................................................
QP::QState Buttons::Not_Pressed(Buttons * const me, QP::QEvt const * const e) {
    QP::QState status_;
    switch (e->sig) {
        // @(/1/0/2/2)
        case Q_ENTRY_SIG: {
            me->m_timeEvt1.postEvery(me, 30);
            status_ = Q_HANDLED();
            break;
        }
        // @(/1/0/2/2)
        case Q_EXIT_SIG: {
            me->m_timeEvt1.disarm();
            status_ = Q_HANDLED();
            break;
        }
        // @(/1/0/2/2/0)
        case TIMEOUT_SIG: {
            // @(/1/0/2/2/0/0)
            if (digitalRead(PUSHBUTTON_PIN)==LOW) {
                QF::publish(Q_NEW(QEvt, PUSHBUTTON_SIG));

                status_ = Q_TRAN(&Buttons::Pressed);
            }
            // @(/1/0/2/2/0/1)
            else {
                status_ = Q_HANDLED();
            }
            break;
        }
        default: {
            status_ = Q_SUPER(&QP::QHsm::top);
            break;
        }
    }
    return status_;
}


//............................................................................
static Buttons l_buttons;             // instantiate the Buttons AO
QActive *AO_Buttons = &l_buttons;     // initialize the global pointer to Buttons
static ControlLED l_controlled;                     // instantiate the Buttons AO
QActive *AO_ControlLED = &l_controlled;             // initialize the global pointer to Buttons


//............................................................................
void setup() {
    BSP_init(); // initialize the BSP
    QF::init(); // initialize the framework and the underlying RT kernel

                                                  // initialize event pools...
    QF::poolInit(l_smlPoolSto, sizeof(l_smlPoolSto), sizeof(l_smlPoolSto[0]));

    QF::psInit(l_subscrSto, Q_DIM(l_subscrSto));     // init publish-subscribe

    AO_Buttons->start(1, l_ButtonsQueueSto, Q_DIM(l_ButtonsQueueSto),
                     (void *)0, 0U);        // start the Buttons active object

    AO_ControlLED->start(2, l_ControlLEDQueueSto, Q_DIM(l_ControlLEDQueueSto),
                     (void *)0, 0U);        // start the Buttons active object

    BSP_ledOff();
}

//////////////////////////////////////////////////////////////////////////////
// NOTE: Do not define the loop() function, because this function is
// already defined in the QP port to Arduino


